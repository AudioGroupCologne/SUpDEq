function spikes = decheveigne2023_spiketrain(drive, sr, recfun, nfibers)% DECHEVEIGNE2023_SPIKETRAIN simulate auditory-nerve spike generation%%   Usage:%     spikes=decheveigne2023_spiketrain(drive,sr,recfun,N)%%   Input parameters:%     drive  : (spikes/s) time-varying rate%     sr     : sampling rate (Hz)%     recfun : refractory function (or dead time)%     N      : number of fibers to simulate%%   Output parameters:%     spikes : vector of spike times (s)%% Spike times are double precision floats (no sampling involved). Spike % generation is efficient.%% Spikes are generated in three steps:%    1. A spike train is generated by a _homogenous_ Poisson process%       with a rate equal to the peak instantaneous rate of the driving %       function.%       Spike times are derived from interspike intervals that follow an %       exponential distribution.  The first spike is supposed to occur at%       0 (not included).%    2. The spike train is 'thinned' probabilistically.  The probability of%       survival of a spike is equal to the instantaneous rate (at spike %       time) normalized by its maximum.%    3. The spike train is further thinned probabilistically to simulate %       refractory effects.%   #StatusDoc: Unknown%   #StatusCode: Unknown%   #Verification: Unknown%   #Requirements: Unknown%   #Author: Alain de Cheveigne (2023)%   #Authors: Alejandro Osses (2023): integration in AMT 1.4% This file is licensed unter the GNU General Public License (GPL) either % version 3 of the license, or any later version as published by the Free Software % Foundation. Details of the GPLv3 can be found in the AMT directory "licences" and % at <https://www.gnu.org/licenses/gpl-3.0.html>. % You can redistribute this file and/or modify it under the terms of the GPLv3. % This file is distributed without any warranty; without even the implied warranty % of merchantability or fitness for a particular purpose. if nargin<4||isempty(nfibers); nfibers=1; endif nargin < 3||isempty(recfun); recfun = 0; end % no refractory effectsif nargin < 2; error('!'); return; enddrive=drive(:);if min(drive) < 0	error ('instantaneous rate must be non-negative');endif nfibers>1 % run repeatedly, merge spikes    spikes=[];    for iFiber=1:nfibers        spikes=[spikes; decheveigne2023_spiketrain(drive,sr,recfun,1)];    end    spikes=sort(spikes);    return;end%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% First step: generate enough spikes to cover the duration of the driving functionmax_rate = max(drive);		% peak instantaneous ratedrive = drive/max_rate;		% normalizenspikes=numel(drive)/sr * max_rate * 1.1;% request a bit moreisis = decheveigne2023_spikepoisson(nspikes, max_rate); spikes = cumsum(isis);spikes(spikes*sr > numel(drive)-1) = []; % trim to duration of input% Second step: thin based on instantaneous ratedraw = rand(numel(spikes),1);idxSpikes = fix(spikes .* sr) + 1;		% spike times expressed in sampleskeep = draw < drive(idxSpikes);spikes = keep .* spikes;spikes=nonzeros(spikes);if numel(spikes) < 1; warning('no spikes produced (rate too small?)'); end% Third step: thin again based on interspike intervalif isa(recfun, 'function_handle') || recfun~=0	spikes = decheveigne2023_spikerefractory(spikes, recfun);endif nargout==0    disp('spike_train: no output requested, plot AC histogram');    spike_ach(spikes); % expects spike times    disp(['rate (spikes/s): ',num2str(spike_rate(spikes))])    clear spikesendend % spike_train
%
%   Url: http://amtoolbox.org/amt-1.4.0/doc/modelstages/decheveigne2023_spiketrain.php

function spikes = decheveigne2023_spiketrain(drive, sr, recfun, nfibers)% DECHEVEIGNE2023_SPIKETRAIN simulate auditory-nerve spike generation%%   Usage:%     spikes=decheveigne2023_spiketrain(drive,sr,recfun,N)%%   Input parameters:%     drive  : (spikes/s) time-varying rate%     sr     : sampling rate (Hz)%     recfun : refractory function (or dead time)%     N      : number of fibers to simulate%%   Output parameters:%     spikes : vector of spike times (s)%% Spike times are double precision floats (no sampling involved). Spike % generation is efficient.%% Spikes are generated in three steps:%    1. A spike train is generated by a _homogenous_ Poisson process%       with a rate equal to the peak instantaneous rate of the driving %       function.%       Spike times are derived from interspike intervals that follow an %       exponential distribution.  The first spike is supposed to occur at%       0 (not included).%    2. The spike train is 'thinned' probabilistically.  The probability of%       survival of a spike is equal to the instantaneous rate (at spike %       time) normalized by its maximum.%    3. The spike train is further thinned probabilistically to simulate %       refractory effects.%   #StatusDoc: Unknown%   #StatusCode: Unknown%   #Verification: Unknown%   #Requirements: Unknown%   #Author: Alain de Cheveigne (2023)%   #Authors: Alejandro Osses (2023): integration in AMT 1.4% This file is licensed unter the GNU General Public License (GPL) either % version 3 of the license, or any later version as published by the Free Software % Foundation. Details of the GPLv3 can be found in the AMT directory "licences" and % at <https://www.gnu.org/licenses/gpl-3.0.html>. % You can redistribute this file and/or modify it under the terms of the GPLv3. % This file is distributed without any warranty; without even the implied warranty % of merchantability or fitness for a particular purpose. if nargin<4||isempty(nfibers); nfibers=1; endif nargin < 3||isempty(recfun); recfun = 0; end % no refractory effectsif nargin < 2; error('!'); return; enddrive=drive(:);if min(drive) < 0	error ('instantaneous rate must be non-negative');endif nfibers>1 % run repeatedly, merge spikes    spikes=[];    for iFiber=1:nfibers        spikes=[spikes; decheveigne2023_spiketrain(drive,sr,recfun,1)];    end    spikes=sort(spikes);    return;end%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% First step: generate enough spikes to cover the duration of the driving functionmax_rate = max(drive);		% peak instantaneous ratedrive = drive/max_rate;		% normalizenspikes=numel(drive)/sr * max_rate * 1.1;% request a bit moreisis = decheveigne2023_spikepoisson(nspikes, max_rate); spikes = cumsum(isis);spikes(spikes*sr > numel(drive)-1) = []; % trim to duration of input% Second step: thin based on instantaneous ratedraw = rand(numel(spikes),1);idxSpikes = fix(spikes .* sr) + 1;		% spike times expressed in sampleskeep = draw < drive(idxSpikes);spikes = keep .* spikes;spikes=nonzeros(spikes);if numel(spikes) < 1; warning('no spikes produced (rate too small?)'); end% Third step: thin again based on interspike intervalif isa(recfun, 'function_handle') || recfun~=0	spikes = decheveigne2023_spikerefractory(spikes, recfun);endif nargout==0    disp('spike_train: no output requested, plot AC histogram');    spike_ach(spikes); % expects spike times    disp(['rate (spikes/s): ',num2str(spike_rate(spikes))])    clear spikesendend % spike_train
